#!/usr/bin/env python3

import getopt
import select
import socket
import ssl
import sys

def usage(f=sys.stdout):
    f.write("""\
Usage: %s --tls-cert=FILENAME --tls-key=FILENAME HOST PORT

  --disable-tls        run without TLS
  --tls-cert=FILENAME  use this TLS certificate (required without --disable-tls)
  --tls-key=FILENAME   use this TLS private key (required without --disable-tls)
  --help               show this help
""" % sys.argv[0])

class options(object):
    use_tls = True
    tls_cert_filename = None
    tls_key_filename = None

CLIENT_SOCKETS = set()

def socket_to_username(s):
    return "user %d" % s.fileno()

# Send msg to all connected clients.
def broadcast(msg):
    for s in tuple(CLIENT_SOCKETS):
        try:
            s.sendall(msg)
        except socket.error:
            CLIENT_SOCKETS.remove(s)

# Parse command line options.  (args, options [, long_options ])  Like getopt(), 
# but allow option and non-option arguments to be intermixed
opts, args = getopt.gnu_getopt(sys.argv[1:], "", ["disable-tls", "tls-cert=", "tls-key=", "help"])
for o, a in opts:
    if o == "--disable-tls":
        options.use_tls = False
    elif o == "--tls-cert":
        options.tls_cert_filename = a
    elif o == "--tls-key":
        options.tls_key_filename = a
    elif o == "--help":
        usage()
        sys.exit()
try:
    listen_hostname, listen_port = args
    listen_port = int(listen_port)

#error + exit
except ValueError:   
    usage(sys.stderr) 
    sys.exit(1)

#error + exit
if options.use_tls and (options.tls_cert_filename is None or options.tls_key_filename is None):
    print("--tls-cert and --tls-key are required unless --disable-tls is used", file=sys.stderr)
    sys.exit(1)  

# Open the listening socket.
listen_socket = socket.socket(socket.AF_INET)  # address family   internet protocol family internetwork: UDP, TCP, etc.
listen_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1) #setsockopt(level,optname,value)   
#SOL_SOCKET is the socket layer itself 
#SO_REUSEADDR port can be reuse immediately
listen_socket.bind((listen_hostname, listen_port))   # bind(host, port)
listen_socket.listen(0) #1 active connection and no backlog possible

if options.use_tls:
    ############################################ step 2?  ####################################
   
    #openssl req -new -x509 -days 365 -nodes -out cert.pem -keyout key.pem
    '''
    Create a new SSL context. 
    You must pass protocol which must be one of the PROTOCOL_* 
    constants defined in this module. PROTOCOL_SSLv23 is currently 
    recommended for maximum interoperability.
    '''

    # channel encryption protocol 1 1_1 1_2
    # ssl.PROTOCOL_TLSv1_2 
    # Available only with openssl version 1.0.1+

    '''
    done? >>> disable certificate verification (CERT_NONE;the server does not authenticate clients) 
    done? >>> load the certificate chain consisting of my.crt and my.key

    '''
    context = ssl.SSLContext(ssl.PROTOCOL_TLSv1_2)
    context.verify_mode = ssl.CERT_NONE
    context.load_cert_chain(certfile="my.crt", keyfile="my.key")

    listen_socket = context.wrap_socket(listen_socket, server_side = True)

    '''
    pem format?????????????????????????
    load_cert_chain
    Load a private key and the corresponding certificate. 
    The certfile string must be the path to a single file in 
    PEM format containing the certificate as well as any number 
    of CA certificates needed to establish the certificateâ€™s authenticity. 
    The keyfile string, if present, must point to a file containing the 
    private key in. Otherwise the private key will be taken from certfile 
    as well. See the discussion of Certificates for more information on 
    how the certificate is stored in the certfile.


    '''
    # TODO
    # Wrap listen_socket in TLS and assign the resulting socket.SSLSocket back
    # to the listen_socket variable.
    # raise NotImplementedError("TLS mode not implemented")

while True:
    # select.select will notify us which sockets are ready to read.
    rset, _, _ = select.select([listen_socket] + list(CLIENT_SOCKETS), [], [])   #rs, ws, es = select.select(inputs,[],[]) input, output, exception
    
    for s in rset:
        if s == listen_socket:
            # s is listen_socket, accept a connection.
            try:
                client_socket, _ = listen_socket.accept()
            except ssl.SSLError:
                continue

            ###################### try succeed #########################
            CLIENT_SOCKETS.add(client_socket)
            broadcast(("*** %s entered the room.\n" % socket_to_username(client_socket)).encode())   
            # s is a client socket, read and broadcast.
            try:
                data = s.recv(1024)

            ############### different kinds of error ###################### 
            except (ssl.SSLWantReadError, ssl.SSLWantWriteError):
                continue
            except socket.error:
                data = None

            ''' send msg to all'''
            if data:
                broadcast(("<%s> " % socket_to_username(s)).encode() + data.rstrip(b"\n") + b"\n")
            else:
                ''' VS-----> CLIENT_SOCKETS.add(client_socket)  '''
                CLIENT_SOCKETS.remove(s)
                broadcast(("*** %s left the room.\n" % socket_to_username(s)).encode())
